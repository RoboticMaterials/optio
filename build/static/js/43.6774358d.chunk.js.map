{"version":3,"sources":["components/map/task_paths/task_paths.js"],"names":["TaskPaths","props","route","selectedTaskReducer","useSelector","state","tasksReducer","selectedTask","selectedHoveringTask","positions","positionsReducer","stations","stationsReducer","dispatch","useDispatch","stateRef","useRef","current","loadPositionId","load","unload","useState","x","y","x1","setX1","y1","setY1","x2","setX2","y2","setY2","e","clientX","clientY","lockToMouse","key","setTaskAttributes","_id","exitTaskPath","useEffect","unloadPositionId","getLoadPositionId","getUnloadPositionId","startPos","endPos","window","addEventListener","removeEventListener","tempX2","tempY2","lineLen","Math","sqrt","pow","lineRot","atan2","arrowRot","PI","dashes","Array","ceil","d3","scale","keys","primaryColor","secondaryColor","dashColor","id","stdDeviation","result","in","strokeWidth","stroke","strokeLinecap","map","delta","transform","cos","sin","viewBox","points","fill"],"mappings":"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","file":"static/js/43.6774358d.chunk.js","sourcesContent":["import React, { useState, useEffect, useRef } from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\n\n// Import Actions\nimport { setTaskAttributes } from \"../../../redux/actions/tasks_actions\";\nimport {\n  getLoadPositionId,\n  getUnloadPositionId,\n} from \"../../../methods/utils/route_utils\";\n\nexport default function TaskPaths(props) {\n  const { route } = props;\n\n  const selectedTaskReducer = useSelector(\n    (state) => state.tasksReducer.selectedTask\n  );\n  const selectedHoveringTask = useSelector(\n    (state) => state.tasksReducer.selectedHoveringTask\n  );\n  const positions = useSelector((state) => state.positionsReducer.positions);\n  const stations = useSelector((state) => state.stationsReducer.stations);\n  const dispatch = useDispatch();\n\n  let selectedTask = null;\n\n  // This sets the selected task to either whats in the reducer or whats being passed in through props\n  // It would be using props because this task path is part of a process\n  if (!!route) {\n    selectedTask = route;\n  } else if (!!selectedHoveringTask) {\n    selectedTask = selectedHoveringTask;\n  } else {\n    selectedTask = selectedTaskReducer;\n  }\n\n  const stateRef = useRef();\n  stateRef.current = selectedTask;\n\n  const loadPositionId = selectedTask?.load;\n  const unloadPositionId = selectedTask?.unload;\n\n  const [mousePos] = useState({ x: 0, y: 0 });\n\n  const [x1, setX1] = useState(0);\n  const [y1, setY1] = useState(0);\n  const [x2, setX2] = useState(null);\n  const [y2, setY2] = useState(null);\n\n  // To be able to remove the event listener, we need to reference the same function.\n  // Therefore we save the function in the state\n  const [lockToMouse] = useState(() => (e) => {\n    setX2(e.clientX);\n    setY2(e.clientY);\n  });\n\n  // A callback that will set the load position to null when you press escape\n  const [exitTaskPath] = useState(() => (e) => {\n    if (e.key == \"Escape\") {\n      dispatch(setTaskAttributes(stateRef.current._id, { load: null }));\n    }\n  });\n\n  // Set the start and end position if they exist\n  useEffect(() => {\n    let loadPositionId, unloadPositionId\n    if (!!selectedTask) {\n      loadPositionId = getLoadPositionId(selectedTask);\n      unloadPositionId = getUnloadPositionId(selectedTask);\n    } else {\n      loadPositionId = getLoadPositionId(selectedHoveringTask);\n      unloadPositionId = getUnloadPositionId(selectedHoveringTask);\n    }\n\n    if (selectedTask !== null || selectedHoveringTask !== null) {\n      if (loadPositionId !== null) {\n        // Check to see if its a station or position\n        const startPos = !!positions[loadPositionId]\n          ? positions[loadPositionId]\n          : stations[loadPositionId];\n        if (startPos) {\n          setX1(startPos.x);\n          setY1(startPos.y);\n        }\n      }\n      if (unloadPositionId !== null) {\n        // Check to see if its a station or position\n        const endPos = !!positions[unloadPositionId]\n          ? positions[unloadPositionId]\n          : stations[unloadPositionId];\n        if (endPos) {\n          setX2(endPos.x);\n          setY2(endPos.y);\n        }\n      }\n    }\n  });\n  \n  // If there is a load position but not an unload, set a listener to set the endpoint to the mouse position\n  useEffect(() => {\n    const loadPositionId = getLoadPositionId(selectedTask);\n    const unloadPositionId = getUnloadPositionId(selectedTask);\n\n    window.addEventListener(\"mousedown\", lockToMouse, false);\n\n    if (\n      selectedTask !== null &&\n      loadPositionId !== null &&\n      unloadPositionId === null\n    ) {\n      setX2(x1);\n      setY2(y1);\n      window.addEventListener(\"mousemove\", lockToMouse, false);\n      window.addEventListener(\"keydown\", exitTaskPath);\n    } else {\n      window.removeEventListener(\"mousemove\", lockToMouse, false);\n      window.removeEventListener(\"keydown\", exitTaskPath);\n    }\n\n    return () => {\n      window.removeEventListener(\"mousedown\", lockToMouse, false);\n      window.removeEventListener(\"mousemove\", lockToMouse, false);\n      window.removeEventListener(\"keydown\", exitTaskPath);\n    };\n  }, [selectedTask]);\n\n  if (selectedTask !== null && loadPositionId != null) {\n    let tempX2 = !!x2 ? x2 : x1\n    let tempY2 = !!y2 ? y2 : y1\n    const lineLen = Math.sqrt(Math.pow(tempX2 - x1, 2) + Math.pow(tempY2 - y1, 2));\n    const lineRot = Math.atan2(tempY2 - y1, tempX2 - x1);\n    const arrowRot = (lineRot * 180) / Math.PI;\n\n    const dashes = [\n      ...Array(Math.ceil(lineLen / (10 * props.d3.scale))).keys(),\n    ];\n\n    // Changes the color based on whether it's a selected task or part of a process\n    const primaryColor = selectedHoveringTask?._id === route?._id ? 'rgba(56, 235, 135, 0.95)' : 'rgba(255, 182, 46, 0.95)'\n    const secondaryColor = selectedHoveringTask?._id === route?._id ? 'rgba(184, 255, 215, 0.7)' : 'rgba(255, 236, 201, 0.7)'\n    const dashColor = selectedHoveringTask?._id === route?._id ? 'rgba(56, 235, 135, 0.95)' : 'rgba(255, 182, 47, 0.95)'\n    return (\n      <>\n        <g>\n          <defs>\n            {/* a transparent glow that takes on the colour of the object it's applied to */}\n            <filter id=\"glow\">\n              <feGaussianBlur stdDeviation=\"1\" result=\"coloredBlur\" />\n              <feMerge>\n                <feMergeNode in=\"coloredBlur\" />\n                <feMergeNode in=\"SourceGraphic\" />\n              </feMerge>\n            </filter>\n          </defs>\n\n          <line\n            x1={`${x1}`}\n            y1={`${y1}`}\n            x2={`${!!x2 ? x2 : x1}`}\n            y2={`${!!y2 ? y2 : y1}`}\n            strokeWidth={`${props.d3.scale * 8}`}\n            stroke={primaryColor}\n            strokeLinecap=\"round\"\n          />\n          <line\n            x1={`${x1}`}\n            y1={`${y1}`}\n            x2={`${!!x2 ? x2 : x1}`}\n            y2={`${!!y2 ? y2 : y1}`}\n            strokeWidth={`${props.d3.scale * 6}`}\n            stroke={secondaryColor}\n            strokeLinecap=\"round\"\n          />\n\n          {dashes.map((delta) => (\n            <g\n              key={`arrow-${delta}`}\n              transform={`translate(${\n                x1 + delta * props.d3.scale * 10 * Math.cos(lineRot)\n              } ${y1 + delta * props.d3.scale * 10 * Math.sin(lineRot)})`}\n            >\n              <g\n                viewBox=\"-50 -50 50 50\"\n                transform={`rotate(${arrowRot}) scale(${\n                  0.05 * props.d3.scale\n                })`}\n              >\n                <polygon points=\"-40,-50 -40,50 40,0\" fill={dashColor} />\n              </g>\n            </g>\n          ))}\n        </g>\n      </>\n    );\n  }\n\n  return null;\n}\n"],"sourceRoot":""}
{"version":3,"sources":["containers/logger/logger.js","../node_modules/react-scripts/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/react-scripts/node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/react-scripts/node_modules/@babel/runtime/helpers/esm/inherits.js","../node_modules/react-scripts/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/react-scripts/node_modules/@babel/runtime/helpers/esm/createSuper.js","../node_modules/react-scripts/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/react-scripts/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/react-scripts/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/react-scripts/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js"],"names":["LoggerContainer","props","disableAll","logger","trace","Object","values","loggers","forEach","redux_logger","index","log","getLogger","name","setLevel","setState","enableAll","updateLoggers","existingLoggerNames","getLoggers","map","state","includes","level","enabled","getLevel","checkForLoggers","a","loaded","reduxLoggerNames","newLoggers","newLogger","info","push","addLoggers","loggersCopy","deepCopy","loggerConfig","postLoggers","removeLogger","loggerNames","debug","constructor","this","prevProps","prevState","snapshot","currentReduxLoggerNames","keys","prevReduxLoggerNames","arraysEqual","Component","connect","localReducer","dispatch","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","i","length","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","prototype","_inherits","subClass","superClass","create","value","_possibleConstructorReturn","self","call","assertThisInitialized","_createSuper","Derived","hasNativeReflectConstruct","isNativeReflectConstruct","result","Super","getPrototypeOf","NewTarget","Reflect","construct","arguments","apply","_assertThisInitialized","ReferenceError","_getPrototypeOf","o","setPrototypeOf","__proto__","_setPrototypeOf","p","_isNativeReflectConstruct","sham","Proxy","Date","toString","e"],"mappings":"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","file":"static/js/31.25c411a3.chunk.js","sourcesContent":["/*\nREAD-ME\n\nDO ALL CONTROLLING OF LOG LEVELS IN THIS CONTAINER, NEVER ANYWHERE ELSE\n\nInstructions of creating a new logger:\n=====================================\n\n1. import logger from src/logger.js'\n\n2. create a new logger\n    this.logger = logger.getLogger(~ENTER LOGGER NAME HERE~)\n\n3. use logger\n    this.logger.info('Here is a message', hereIsAVariable);\n\n*/\n\n// import external dependencies\nimport React, {Component} from 'react';\nimport { connect } from 'react-redux';\n\n// import actions\nimport { getLoggers, postLoggers } from '../../redux/actions/local_actions';\n\n// import methods\nimport { deepCopy, arraysEqual } from '../../methods/utils/utils'\n\n// import logger\nimport log from '../../logger.js';\n\nclass LoggerContainer extends Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n          //loggers: log.getLoggers(),\n          disableAll: false,\n          enableAll: false,\n        }\n\n        this.logger = log.getLogger(this.constructor.name);\n\n    }\n\n    componentDidMount() {\n        // initial call to check for loggers\n        this.checkForLoggers();\n\n        // check for new loggers on interval\n        // doesn't appear to be necessary at the moment\n        // this.checkLoggersInterval = setInterval(() => this.checkForLoggers(), 10000);\n\n    }\n\n    componentWillUnmount() {\n        // clearInterval(this.checkLoggersInterval);\n    }\n\n    componentDidUpdate(prevProps, prevState, snapshot) {\n        // const currentReduxLoggers = this.props.loggers;\n        // const prevReduxLoggers = prevProps.loggers;\n\n        const currentReduxLoggerNames = Object.keys(this.props.loggers);\n        const prevReduxLoggerNames = Object.keys(prevProps.loggers);\n\n        const loggersChanged = !arraysEqual(currentReduxLoggerNames, prevReduxLoggerNames);\n\n        if(loggersChanged) {\n            // this.checkForLoggers();\n        }\n\n\n\n    }\n\n\n    /*\n        This function disables all loggers\n    */\n    disableAll = () => {\n      this.logger.trace('disableAll called')\n      //Object.values(log.getLoggers()).forEach((logger, index) => {\n      //  logger.setLevel(5);\n      //})\n\n      Object.values(this.props.loggers).forEach((redux_logger, index) => {\n\n          let logger = log.getLogger(redux_logger.name);\n          logger.setLevel(5);\n\n      })\n\n      log.disableAll();\n      this.setState({disableAll: true, enableAll: false});\n    }\n\n    /*\n        This function enables all loggers\n    */\n    enableAll = () => {\n      //Object.values(log.getLoggers()).forEach((logger, index) => {\n      //  logger.setLevel(0);\n      //})\n\n      Object.values(this.props.loggers).forEach((redux_logger, index) => {\n          let logger = log.getLogger(redux_logger.name);\n          logger.setLevel(0);\n      })\n      log.enableAll();\n      this.setState({enableAll: true, disableAll: false});\n    }\n\n\n\n    /*\n        This function updates the actual logger settings to match the config in redux\n    */\n    updateLoggers = () => {\n\n        const existingLoggerNames = Object.values(log.getLoggers()).map((logger, index) => logger.name);\n\n        //If disableAll all is true\n        if(this.props.disableAll && !this.state.disableAll){\n          this.disableAll();\n        }\n\n        if(!this.props.disableAll && this.state.disableAll){\n          this.setState({disableAll: false});\n        }\n\n        //If mute all is false\n        if(this.props.enableAll && !this.state.enableAll){\n          this.enableAll();\n        }\n\n        if(!this.props.enableAll && this.state.enableAll){\n          this.setState({enableAll: false});\n        }\n\n        // only perform the logger updates if neither disableAll nor enableAll are true\n        if(!this.props.disableAll && !this.props.enableAll) {\n\n          // for each logger in redux:\n          //    get the actual logger\n          //    set the level to match the redux config\n          Object.values(this.props.loggers).forEach((redux_logger, index) => {\n\n            if(existingLoggerNames.includes(redux_logger.name)) {\n                let logger = log.getLogger(redux_logger.name);\n\n                let level = redux_logger.level;\n                let enabled = redux_logger.enabled;\n\n                // if logger isn't enabled and isn't already set to silent,\n                // set it to silent\n                if(!enabled && (logger.getLevel() !== 5)) {\n                  logger.setLevel(5);\n                }\n\n                // if the logger is enabled, and the actual level doesn't\n                // match the level config in redux, update it\n                if(enabled && (logger.getLevel() !== level)) {\n                  logger.setLevel(level);\n                }\n            }\n\n          });\n        }\n\n    }\n\n\n\n\n    /*\n        This function checks if any loggers exist that do not exist in the redux store\n        If a logger is found that isn't in the store, it will add a new logger object to the store\n    */\n    checkForLoggers = async () => {\n        // true if the redux store has read the logger config\n        // false otherwise\n        const { loaded } = this.props;\n\n        // only perform the check if the saved settings have been loaded\n        if(true) {\n\n          // get all loggers\n          const loggers = Object.values(log.getLoggers());\n          const loggerNames = loggers.map((logger) => logger.name);\n\n          // get name of loggers in redux\n          const reduxLoggerNames = Object.values(this.props.loggers).map((logger, index) => {\n            return logger.name;\n          });\n\n          // for each logger\n          //    check if the redux store contains a logger with the same name\n          //    if a logger isn't found, create a new one\n          let newLoggers = [];\n          loggers.forEach( async (logger, index) => {\n\n              let name = logger.name;\n              let level = logger.getLevel();\n\n              // if level is equal to 5 (silent), enabled is false, and true otherwise\n              let enabled = level === 5 ? false : true;\n\n              if(!reduxLoggerNames.includes(name)) {\n\n                  let newLogger = {\n                    name,\n                    level,\n                    enabled\n                  };\n\n                  this.logger.info('Adding new logger', newLogger)\n\n                  newLoggers.push(newLogger);\n              }\n          });\n\n          await this.addLoggers(newLoggers);\n\n\n          // this block will remove loggers from redux that don't actually exist\n          // this will be necessary for loggers that have been deleted from code\n          // but still have local saved settings\n\n          /*\n          let removeLoggers = [];\n          // delete\n          reduxLoggerNames.forEach( (reduxLoggerName, index) => {\n              if(!loggerNames.includes(reduxLoggerName)) {\n                this.logger.info(\"Adding logger to list to be removed\", reduxLoggerName);\n                removeLoggers.push(reduxLoggerName);\n              }\n          });\n\n          this.logger.info('About to remove loggers', removeLoggers)\n          if(removeLoggers.length > 0) {\n              //  await this.removeLogger(removeLoggers);\n\n          }\n          */\n\n\n        }\n    }\n\n    /*\n        This function adds a new logger to the redux store\n    */\n    addLoggers = async (newLoggers) => {\n        const { loggers, enableAll, disableAll, loaded } = this.props;\n\n        // copy loggers (don't directly modify state)\n        let loggersCopy = deepCopy(loggers);\n\n        newLoggers.forEach((newLogger, index) => {\n            // add newLogger to loggers copy\n            loggersCopy[newLogger.name] = newLogger;\n        })\n\n\n        // create logger config\n        var loggerConfig = {};\n        loggerConfig['loggers'] = loggersCopy;\n        loggerConfig['enableAll'] = enableAll;\n        loggerConfig['disableAll'] = disableAll;\n\n        await this.props.postLoggers(loggerConfig, loaded);\n    }\n\n    /*\n        This function removes logger from the redux store\n    */\n    removeLogger = async (loggerNames) => {\n        const { loggers, enableAll, disableAll } = this.props;\n\n        this.logger.debug(\"removeLogger: loggerNames\", loggerNames);\n        this.logger.debug(\"removeLogger: loggers\", loggers)\n\n        // copy loggers (don't directly modify state)\n        let loggersCopy = deepCopy(loggers);\n\n        loggerNames.forEach((name, index) => {\n          // delete logger\n          delete loggersCopy[name];\n        })\n\n\n        this.logger.debug(\"removeLogger: loggersCopy after removal\", loggersCopy)\n\n        // create logger config\n        var loggerConfig = {};\n        loggerConfig['loggers'] = loggersCopy;\n        loggerConfig['enableAll'] = enableAll;\n        loggerConfig['disableAll'] = disableAll;\n\n        await this.props.postLoggers(loggerConfig);\n    }\n\n    /*\n    printLoggers = () => {\n      let loggers = Object.values(log.getLoggers());\n      console.log('printLoggers')\n\n      loggers.forEach((logger, index) => {\n\n        console.log(logger.name)\n        console.log(logger.getLevel())\n        console.log(logger)\n      })\n\n\n    }\n    */\n\n    /*\n    printReduxLoggers = () => {\n      let loggers = Object.values(this.props.loggers);\n      console.log('printReduxLoggers')\n\n      loggers.forEach((logger, index) => {\n\n        console.log(logger.name)\n        console.log(logger.level)\n        console.log(logger.enabled)\n      })\n\n\n    }\n    */\n\n    render(){\n\n      this.updateLoggers();\n\n      //this.printLoggers()\n      //this.printReduxLoggers()\n\n\n      return(\n        <>\n        </>\n      );\n    }\n}\n\nconst mapStateToProps = function(state) {\n  return {\n    loggers: state.localReducer.loggers,\n    enableAll: state.localReducer.enableAll,\n    disableAll: state.localReducer.disableAll,\n    loaded: state.localReducer.loaded,\n  };\n};\n\nconst mapDispatchToProps = (dispatch, props) => {\n  return {\n    postLoggers: (loggerConfig) => dispatch(postLoggers(loggerConfig))\n  };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(LoggerContainer);\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","import setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport isNativeReflectConstruct from \"@babel/runtime/helpers/esm/isNativeReflectConstruct\";\nimport possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}"],"sourceRoot":""}